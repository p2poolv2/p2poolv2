---- MODULE ShareChain ----
EXTENDS Naturals, Sequences, TLC, FiniteSets, Integers, SequencesExt

CONSTANTS 
    Processes,                  \* Set of processes that generate shares
    MaxShares,                  \* Maximum number of shares per process
    Work,                       \* Work/difficulty parameter for shares
    MaxUnclesDepth,             \* Maximum depth for uncles included in a share
    MaxUncles,                  \* Maximum number of uncles included in a share
    MaxBitcoinHeight            \* Current Bitcoin network height for validating received shares

VARIABLES
    stored_shares,              \* Set of all shares across all processes
    parent,                     \* Parent references for each share
    uncles,                     \* Uncle references for each share
    chain_work,                 \* Total work accumulated up to each candidate height, if any
    expected_height,            \* expected height of each share in the chain at each process.
                                \*Shares may or may not candidate or confirm to this height
    candidates,                 \* candidates of each share in the chain at each process
    confirmed,                  \* confirmed of each share in the chain at each process
    received_shares,            \* Queue of shares received from other processes, but not validated yet
    validation_status,          \* Validation status of received shares
    share_status,               \* Candidate/Confirmed status of shares
    share_queue,                \* Queue of shares that have been generated but not yet sent to peers,
    bitcoin_height,             \* Bitcoin network height associated with each share
    spend_dependencies          \* Dependency Share -> Share. The key share is spending the value share.
vars == <<stored_shares, share_queue, uncles, parent, bitcoin_height, 
          confirmed, candidates, received_shares, validation_status, 
          spend_dependencies, chain_work, expected_height, share_status>>

(****************************************************************************)
(* Genesis share definition                                                 *)
(****************************************************************************)
Genesis == [process |-> CHOOSE p \in Processes: TRUE, work |-> 1, bitcoin_height |-> 0]

(****************************************************************************)
(* Use NoHeight to indicate share not found in height sequences             *)
(* Sequences are indexed from 1                                             *)
(****************************************************************************)
NoHeight == 0

(****************************************************************************)
(* Total shares across all processes                                        *)
(****************************************************************************)
TotalShares == MaxShares * Cardinality(Processes)

(****************************************************************************)
(* Genesis height is 1, aligns with sequence indexed from 1                 *)
(****************************************************************************)
Height == (1..TotalShares)

(****************************************************************************)
(* A share is a tuple containing:                                           *)
(* -- process: the generating process                                       *)
(* -- seq: sequence number of share generated by this process               *)
(* -- work: work/difficulty in the share                                    *)
(****************************************************************************)
Share == [
    process: Processes,
    work: Work,
    bitcoin_height: (-1..MaxBitcoinHeight)
]

(****************************************************************************)
(* Define NoShare to indicate absence of a share                            *)
(****************************************************************************)
NoShare == [process |-> CHOOSE p \in Processes: TRUE, work |-> 0, bitcoin_height |-> -1]

(****************************************************************************)
(* Type definitions for all variables                                       *)
(****************************************************************************)
TypeOK ==
    /\ stored_shares \in [Processes -> SUBSET Share]
    /\ parent \in [Share -> Share \cup {Genesis} \cup {NoShare}]
    /\ uncles \in [Share -> SUBSET {Share \cup {Genesis} \cup {NoShare}}]
    /\ chain_work \in [Processes \X (Share \cup {Genesis}) -> Nat]
    /\ expected_height \in [Processes \X Share \cup {Genesis} -> Height \cup {NoHeight}]
    /\ candidates \in [Processes -> Seq(Share)]
    /\ confirmed \in [Processes -> Seq(Share)]
    /\ received_shares \in [Processes -> Seq(Share)]
    /\ validation_status \in [Processes \X Share -> {"None", "Pending", "Valid", "Invalid"}]
    /\ share_status \in [Processes \X Share -> {"None", "Candidate", "Confirmed"}]
    /\ share_queue \in Seq(Share)
    /\ bitcoin_height \in [Processes -> (0..MaxBitcoinHeight)]
    /\ spend_dependencies \in [Share -> SUBSET Share]

(****************************************************************************)
(* Initial state definition                                                 *)
(****************************************************************************)
Init ==
    \* All processes start with genesis share
    /\ stored_shares = [p \in Processes |-> {Genesis}] 
    /\ parent = [s \in Share \cup {Genesis} |-> NoShare]
    /\ uncles = [s \in Share \cup {Genesis} |-> {}]
    \* Candidate chain is empty at the start
    /\ chain_work = [p \in Processes, s \in (Share \cup {Genesis}) |-> 
                        IF s = Genesis THEN 1 ELSE 0]
    /\ expected_height = [p \in Processes, s \in Share |-> 
                            IF s = Genesis THEN 1 ELSE NoHeight]
    /\ candidates = [p \in Processes |-> << >> ]            \* Empty
    /\ confirmed = [p \in Processes |->  << Genesis >> ]    \* Genesis at height 1
    /\ received_shares = [p \in Processes |-> << >>]
    /\ validation_status = [p \in Processes, s \in Share |->
                            IF s = Genesis THEN "Valid" ELSE "None"]
    /\ share_status = [p \in Processes, s \in Share |->
                            IF s = Genesis THEN "Confirmed" ELSE "None"]
    /\ bitcoin_height = [p \in Processes |-> 0]
    /\ share_queue = << >>
    /\ spend_dependencies = [s \in Share |-> {}]

(****************************************************************************)
(* Get the top confirmed share for process p                               *)
(****************************************************************************)
TopConfirmed(p) == confirmed[p][Len(confirmed[p])]

(****************************************************************************)
(* Get the top candidate share for process p                                *)
(****************************************************************************)
TopCandidate(p) ==
    IF Len(candidates[p]) = 0 THEN NoShare
    ELSE
    candidates[p][Len(candidates[p])]

(****************************************************************************)
(* Get the candidate height of a share s on process p                       *)
(* returns NoHeight if not found                                            *)
(* In implementation we replace these scans with more efficient             *)
(* indexing of heights stored as "expected height derived from parent"      *)
(****************************************************************************)
GetCandidateHeight(p, s) == SelectInSeq(candidates[p], LAMBDA v: v = s)

(****************************************************************************)
(* Get the confirmed height of a share s on process p                       *)
(* returns NoHeight if not found                                            *)
(* In implementation we replace these scans with more efficient             *)
(* indexing of heights stored as "expected height derived from parent"      *)
(****************************************************************************)
GetConfirmedHeight(p, s) == SelectInSeq(confirmed[p], LAMBDA v: v = s)

(****************************************************************************)
(* Get uncles for a share s generated by process p.                         *)
(* -- Find all Candidate shares with parents in confirmed with depth >= 3   *)
(* -- filter out those that are not uncles of any other shares              *)
(* -- choose any max 3 shares                                               *)
(* By selecting uncles using only parent in confirmed index check we avoid  *)
(* tracking candidate/confirmed uncles separately and thus don't have to    *)
(* handle such new indexes during chain reorgs                              *)
(* Remember in p2poolv2 uncles transactions are ignored, only main chain    *)
(* transactions impact the inputs/output states                             *)
(****************************************************************************)
UnclesFor(p, s) ==
    LET parent_confirmed_height == GetConfirmedHeight(p, parent[s])
        min_depth == IF parent_confirmed_height > MaxUnclesDepth
                     THEN parent_confirmed_height - MaxUnclesDepth
                     ELSE 1
        \* Get all shares that have parents in confirmed chain within depth range
        all_uncles == UNION {uncles[sh] : sh \in DOMAIN uncles}
        potential_uncles == {u \in stored_shares[p] : 
            /\ u # s
            /\ GetConfirmedHeight(p, parent[u]) # NoHeight
            /\ GetConfirmedHeight(p, parent[u]) >= min_depth
            /\ GetConfirmedHeight(p, parent[u]) < parent_confirmed_height
            /\ u # parent[s]
            /\ u \notin all_uncles}
    \* Select up to MaxUncles uncles
    IN IF Cardinality(potential_uncles) <= MaxUncles 
       THEN potential_uncles
       ELSE CHOOSE subset \in SUBSET potential_uncles : Cardinality(subset) = MaxUncles

(****************************************************************************)
(* Recursive function to compute total work for a set of shares             *)
(****************************************************************************)
RECURSIVE WorkForShares(_)
WorkForShares(shares) ==
    IF shares = {} THEN 0
    ELSE 
        LET firstShare == CHOOSE s \in shares : TRUE
            restShares == shares \ {firstShare}
        IN firstShare.work + WorkForShares(restShares)

(****************************************************************************)
(* Find total work for uncles included in share s on process p              *)
(****************************************************************************)
WorkForUncles(p, s) ==
    LET uncles_s == uncles[s]
    IN WorkForShares(uncles_s)

(****************************************************************************)
(* Host process generates a new share                                       *)
(* -- Creates a share with some work                                        *)
(* -- Track parent for the new share as the current chain tip               *)
(* -- Update tips to include the new share and remove the chain tip         *)
(****************************************************************************)
GenerateShare(p, work) ==
    /\ Cardinality(stored_shares[p]) < MaxShares           \* Limit total shares
    /\ Len(confirmed[p]) > 0                               \* Ensure genesis is present
    /\ work \in Work
    /\ LET
        bitcoin_height_p == CHOOSE h \in (0..MaxBitcoinHeight) : 
                                   h > bitcoin_height[p]
        newShare == [
            process |-> p,
            work |-> work,
            bitcoin_height |-> bitcoin_height_p
        ]
       IN  \* Add new share to the process's shares
           /\ stored_shares' = [stored_shares EXCEPT ![p] = @ \cup {newShare}]
            \* parent is the current chain tip
           /\ parent' = [parent EXCEPT ![newShare] = TopConfirmed(p)]
           \* Immediately mark the new share as valid for local node
           /\ validation_status' = [validation_status EXCEPT ![p, newShare] = "Valid"]
           \* Immediately confirm the new share at local node
           /\ confirmed' = 
                [confirmed EXCEPT ![p] = Append(@, newShare)]
            \* Update confirmed work as parent's work + new share's work + uncles' work
           /\ chain_work' = 
                [chain_work EXCEPT ![p, newShare] = 
                    chain_work[p, TopConfirmed(p)] + work + WorkForShares(UnclesFor(p, newShare))]
            \* select uncles for the new share
           /\ uncles' = [uncles EXCEPT ![newShare] = UnclesFor(p, newShare)]
           \* Enqueue the new share for sending to other processes
           /\ share_queue' = Append(share_queue, newShare)
           \* Set bitcoin height for the new share, it can be any valid height
           /\ bitcoin_height' = [bitcoin_height EXCEPT ![p] = bitcoin_height_p]
           /\ UNCHANGED << received_shares, candidates, 
                           spend_dependencies, expected_height, share_status >>

(****************************************************************************)
(* Receive a share on process p                                             *)
(* The share is added to received_shares, but not made candidate or         *)
(* confirmed yet. Share is only removed from queue when all processes have  *)
(* either received or stored it.                                            *)
(****************************************************************************)
ReceiveShare(p) ==
    /\ share_queue # << >>
    /\ LET s == Head(share_queue)
       IN
        /\ /\ ~Contains(received_shares[p], s)                  \* Only process share if not already received
           /\ s \notin stored_shares[p]                         \* and not already present in stored shares
        /\ bitcoin_height[p] - s.bitcoin_height <= 1            \* Share should be recent enough
        \* Add to received shares
        /\ received_shares' = [received_shares EXCEPT ![p] = Append(@, s)]
        \* Remove from queue only if ALL processes have now received or stored it
        /\ LET allProcessesHaveShare == 
                \A proc \in Processes:
                    \/ Contains(received_shares'[proc], s)
                    \/ s \in stored_shares[proc]
           IN share_queue' = IF allProcessesHaveShare
                             THEN Tail(share_queue)
                             ELSE share_queue
    /\ UNCHANGED << parent, uncles, confirmed, candidates, bitcoin_height, 
                    validation_status, stored_shares, spend_dependencies, chain_work,
                    expected_height, share_status>>

(****************************************************************************)
(* Validate a received share so it can be confirmed later                   *)
(* Validation is independent of parent's status                             *)
(* We could get into modeling txs, but that is not relevant to chain        *)
(* organisation                                                             *)
(****************************************************************************)
ValidateShare(p, s) ==
    /\ s \in stored_shares[p]
    /\ \/ validation_status[p, s] = "None"
        \/ validation_status[p, s] = "Pending" 
    /\ validation_status' = [validation_status EXCEPT ![p, s] = "Valid"]
    /\ UNCHANGED << stored_shares, parent, uncles, confirmed, candidates, bitcoin_height,
                    received_shares, share_queue, spend_dependencies, chain_work,
                    expected_height, share_status >>

(****************************************************************************)
(* Set expected height for a share s on process p based on parent's         *)
(* expected height                                                          *)
(* We should do this only if share has valid PoW                            *)
(* Setting a height implies all parents of a share have been received       *)
(****************************************************************************)
StoreShareAndSetExpectedHeight(p, s) ==
    \* Share has been received
    /\ received_shares[p] # << >>
    /\ s = Head(received_shares[p])
    \* Share must not already have expected height set
    /\ expected_height[p, s] = NoHeight
    \* Parent has been assigned an expected height or is confirmed or candidate
    /\ \/ parent[s] = Genesis
       \/ parent[s] = NoShare
       \/ expected_height[p, parent[s]] # NoHeight
       \/ Contains(candidates[p], parent[s])
       \/ Contains(confirmed[p], parent[s])
    \* All uncles have expected heights set, which implies they have been received
    /\ \A u \in uncles[s] :
        expected_height[p, u] # NoHeight
    /\
        LET parentShare == parent[s]
            parent_height == IF parentShare = NoShare \/ parentShare = Genesis
                                THEN 1 
                                ELSE expected_height[p, parentShare]
        IN
            /\ stored_shares' = [stored_shares EXCEPT ![p] = @ \cup {s}]
                \* Set expected height for the share
            /\ expected_height' = [expected_height EXCEPT ![p, s] = parent_height + 1]
    /\ received_shares' = [received_shares EXCEPT ![p] = Tail(@)]
    /\ UNCHANGED << parent, uncles, confirmed, candidates, bitcoin_height, 
                    share_queue, validation_status,
                    spend_dependencies, chain_work, share_status >>

(****************************************************************************)
(* Mark a received share as candidate without appending to candidate chain  *)
(* or marking it as an orphan share without removing from received shares.  *)
(* When the share can be later appended to the candidate chain, then it is  *)
(* removed from received shares.*)
(*  -- parent has to be a candidate or confirmed share                      *)
(*  -- share is not added to candidate chain                                *)
(*  -- share status is updated to "Candidate"                               *)
(*  -- candidate work is updated for the share                              *)
(*  -- share is not removed from received shares queue                      *)
(***************************************************************************)
MarkShareAsCandidate(p, s) ==
    /\ s \in stored_shares[p]
    \* Share must have expected height set
    /\ expected_height[p, s] # NoHeight
    \* Share must be valid
    /\ validation_status[p, s] = "Valid"
    \* Share must not already be candidate or confirmed
    /\ share_status[p, s] = "None"
    \* Share must not already be candidate or confirmed
    /\ /\ ~Contains(candidates[p], s)
       /\ ~Contains(confirmed[p], s)
    \* Parent must be in candidate or confirmed chain
    /\ \/ Contains(candidates[p], parent[s])
       \/ Contains(confirmed[p], parent[s])
    /\ share_status' = [share_status EXCEPT ![p, s] = "Candidate"]
    \* Set chain work for the share as parent's work + share's work + uncles' work
    /\ chain_work' = [chain_work EXCEPT ![p, s] =
                        chain_work[p, parent[s]] + s.work + WorkForShares(uncles[s])]
    /\ UNCHANGED << stored_shares, parent, uncles, confirmed, candidates,
                    bitcoin_height, share_queue, validation_status,
                    spend_dependencies, expected_height, received_shares >>

(****************************************************************************)
(* Append a received share to the top of candidates                         *)
(* -- parent has to be top candidate                                        *)
(* -- candidate is added to index at the top                                *)
(* -- share is removed from received shares queue                           *)
(****************************************************************************)
AppendShareToCandidates(p, s) == 
    /\ s \in stored_shares[p]
    \* Share must have expected height set
    /\ expected_height[p, s] # NoHeight
    \* Share must be valid
    /\ validation_status[p, s] = "Valid"
    \* Share must have Candidate status
    /\ share_status[p, s] = "Candidate"
    /\ ~Contains(candidates[p], s)                   \* Share must not be in candidate chain
    /\ ~Contains(confirmed[p], s)                    \* Share must not be in candidate chain
    \* Parent must be top candidate
    \* include other sanity checks for height and work
    /\ \/ (/\ TopCandidate(p) = parent[s]
           /\ expected_height[p, s] = Len(candidates[p]) + 1 
           /\ chain_work[p, s] > chain_work[p, TopCandidate(p)])
       \/ Len(candidates[p]) = 0
    /\ candidates' = [candidates EXCEPT ![p] = Append(@, s)]
    /\ UNCHANGED << stored_shares, parent, uncles, confirmed, bitcoin_height,
                    share_queue, validation_status, spend_dependencies,
                    expected_height, share_status, chain_work, received_shares >>

(****************************************************************************)
(* Get the chain starting from given share for process p to the first       *)
(* candidate (branch point) - in reverse                                    *)
(* Note the chain is not explicitly required to be stored anywhere, it is   *)
(* constructed by following parent links recursively                        *)
(* Returns Seq << branch point .. s >>                                      *)
(****************************************************************************)
RECURSIVE GetBranchInIndex(_, _, _)
GetBranchInIndex(p, s, index) ==
    IF \/ s = Genesis                  \* genesis as end of candidate chain
       \/ Contains(index[p], s)        \* ancestor in candidate chain
    THEN 
        << s >>
    ELSE 
        GetBranchInIndex(p, parent[s], index) \o << s >>

(****************************************************************************)
(* For a share with Candidate status and more work than top, reorg          *)
(* -- get a share that has more work than top candidate, is marked Candidate*)
(* but not yet in candidates chain                                          *)
(* -- find common ancestor between top candidate and the new share, call it *)
(*   branch point                                                           *)
(* -- remove old chain, the chain from top candidate to branch point from   *)
(*   the candidate index                                                    *)
(* -- push chain from branch point to the new share on to candidate index   *)
(****************************************************************************)
ReorgCandidateChain(p, s) ==
    \* Share must have Candidate status
    /\ share_status[p, s] = "Candidate"
    \* Share must be valid
    /\ validation_status[p, s] = "Valid"
    \* Share must have expected height set
    /\ expected_height[p, s] # NoHeight
    \* There must be existing candidates to reorg against, else we just AppendShareToCandidates
    /\ Len(candidates[p]) > 0
    \* Share must have more work than top candidate. With same work, we don't reorg
    /\ chain_work[p, s] > chain_work[p, TopCandidate(p)]
    \* Find branch point
    /\ LET  candidate_branch == GetBranchInIndex(p, s, candidates)
            branchPoint == Head(candidate_branch)
            reorged_out_chain == 
                SubSeq(candidates[p],
                    GetCandidateHeight(p, branchPoint),
                    GetCandidateHeight(p, TopCandidate(p))) 
        IN  
            /\ \* Replace candidates chain with new chain from genesis -> branch point -> new tip
                candidates' = 
                    [candidates EXCEPT ![p] = 
                        SubSeq(@,1, GetCandidateHeight(p, parent[branchPoint])) \o candidate_branch]
    /\ UNCHANGED << stored_shares, parent, uncles, confirmed, bitcoin_height,
                    share_queue, validation_status, spend_dependencies,
                    chain_work, expected_height, share_status, received_shares >>

(****************************************************************************)
(* For a share with Candidate status and more work than top confirmed,      *)
(* reorg confirmed chain to include the new share                           *)
(* -- get a share that has more work than top confirmed, is marked Candidate*)
(*   but not yet in confirmed chain                                         *)
(* -- find common ancestor between top confirmed and the new share, call it *)
(*   fork point                                                             *)
(* -- remove old chain, the chain from top confirmed to fork point from the *)
(*   confirmed index                                                        *)
(* -- push chain from fork point to the new share on to confirmed index     *)
(****************************************************************************)
ReorgConfirmedChain(p, s) ==
    \* Chain tip being reorged in must be candidate
    /\ share_status[p, s] = "Candidate"
    \* Share is not direct child of current confirmed tip
    /\ parent[s] # TopConfirmed(p)
    \* Chain tip being reorged must have more work than current confirmed tip
    /\ chain_work[p, s] > chain_work[p, TopConfirmed(p)]
    \* Share must be in the candidate index
    /\ Contains(candidates[p], s)
    \* Find branch point from chain tip being reorged in to confirmed chain
    /\ LET  confirmed_branch == GetBranchInIndex(p, s, confirmed)
            forkPoint == Head(confirmed_branch)
            reorged_out_chain == 
                SubSeq(confirmed[p],
                    GetConfirmedHeight(p, forkPoint),
                    GetConfirmedHeight(p, TopConfirmed(p)))
        IN  
            \* spend conditions in the confirmed_branch are not violated
            /\ \A i \in 1..Len(confirmed_branch) :
                \A dep \in spend_dependencies[confirmed_branch[i]] :
                    GetConfirmedHeight(p, dep) < GetConfirmedHeight(p, confirmed_branch[i])
            \* Replace confirmed chain with new chain from genesis -> fork point -> new tip
            /\ confirmed' =
                [confirmed EXCEPT ![p] = 
                    SubSeq(@,1, GetConfirmedHeight(p, parent[forkPoint])) \o confirmed_branch]
            \* Clear out the reorged out chain from candidates
            /\ candidates' = 
                [candidates EXCEPT ![p] = 
                    SubSeq(candidates[p], 1, GetCandidateHeight(p, forkPoint))]
            \* Update share status for reorged out chain and confirmed branch
            /\ share_status' = 
                [share_status EXCEPT 
                    ![p, s] = [sh \in Share |-> 
                        IF sh \in {reorged_out_chain[i] : i \in 1..Len(reorged_out_chain)}
                        THEN "Candidate"
                        ELSE IF sh \in {confirmed_branch[i] : i \in 1..Len(confirmed_branch)}
                        THEN "Confirmed"
                        ELSE share_status[p, sh]][s]]
    /\ UNCHANGED << stored_shares, parent, uncles, bitcoin_height,
                    share_queue, validation_status, spend_dependencies,
                    chain_work, expected_height, received_shares >>
            
(****************************************************************************)
(* Confirm the candidate chain up to top candidate                          *)
(* -- Require that no shares in the candidate chain have spending dependency*)
(*   on a share in the future                                               *)
(* -- Move all candidates to confirmed chain                                *)
(* -- Note: We don't track candidate/confirmation state of uncles. The state*)
(*   of their parent on the candidate/confirmed chain is what matters       *) 
(****************************************************************************)
ConfirmCandidateChain(p) ==
    /\ Len(candidates[p]) > 0
    \* Confirm candidates can only extend from current confirmed tip
    \* Otherwise we reorg chain
    /\ TopConfirmed(p) = parent[candidates[p][1]]
    /\ \A i \in 1..Len(candidates[p]) :
        \A dep \in spend_dependencies[candidates[p][i]] :
            GetCandidateHeight(p, dep) < GetCandidateHeight(p, candidates[p][i])
    /\ \A i \in 1..Len(candidates[p]) :
        share_status' = [share_status EXCEPT ![p, candidates[p][i]] = "Confirmed"]
    \* Make candidate chain the new confirmed chain
    /\ confirmed' = [confirmed EXCEPT ![p] = confirmed[p] \o candidates[p]]
    \* Clear candidates
    /\ candidates' = [candidates EXCEPT ![p] = << >>]
    /\ UNCHANGED << stored_shares, parent, uncles, bitcoin_height, share_queue,
                    received_shares, validation_status, spend_dependencies,
                    chain_work, expected_height >>

(****************************************************************************)
(* Next-state relation                                                      *)
(****************************************************************************)
Next ==
    \/ \E p \in Processes,
        work \in Work : GenerateShare(p, work)
    \/ \E p \in Processes : ReceiveShare(p)
    \/ \E p \in Processes, s \in Share : StoreShareAndSetExpectedHeight(p, s)
    \/ \E p \in Processes, s \in Share : ValidateShare(p, s)
    \/ \E p \in Processes, s \in Share : AppendShareToCandidates(p, s)
    \/ \E p \in Processes, s \in Share : MarkShareAsCandidate(p, s)
    \/ \E p \in Processes, s \in Share : ReorgCandidateChain(p, s)
    \/ \E p \in Processes, s \in Share : ReorgConfirmedChain(p, s)
    \/ \E p \in Processes : ConfirmCandidateChain(p)

(****************************************************************************)
(* Fairness constraints that must be met by the spec                        *)
(****************************************************************************)
Fairness == 
    /\ WF_vars(\E p \in Processes: ReceiveShare(p))
    /\ WF_vars(\E p \in Processes, s \in Share: ValidateShare(p, s))
    /\ WF_vars(\E p \in Processes, s \in Share: StoreShareAndSetExpectedHeight(p, s))
    /\ WF_vars(\E p \in Processes, s \in Share: AppendShareToCandidates(p, s))
    /\ WF_vars(\E p \in Processes, s \in Share: MarkShareAsCandidate(p, s))
    /\ WF_vars(\E p \in Processes, s \in Share: ReorgCandidateChain(p, s))
    /\ WF_vars(\E p \in Processes, s \in Share: ReorgConfirmedChain(p, s))
    /\ WF_vars(\E p \in Processes: ConfirmCandidateChain(p))

\* All received shares are eventually processed (not stuck in queue)
NoStuckShares ==
    \A p \in Processes:
        [](Len(received_shares[p]) > 0 => 
            <>(Len(received_shares[p]) = 0))

\* Share queue eventually gets drained
ShareQueueDrained ==
    [](Len(share_queue) > 0 => <>(Len(share_queue) = 0))

\* Convergence: Eventually nodes have confirmed chains with same work
Convergence ==
    []((
        /\ \A p \in Processes: Len(received_shares[p]) = 0
        /\ Len(share_queue) = 0
        /\ \A p \in Processes: Len(confirmed[p]) = MaxShares                
    ) => <>(\A p1, p2 \in Processes: 
            chain_work[p1, TopConfirmed(p1)] = chain_work[p2, TopConfirmed(p2)]))


Spec == Init /\ [][Next]_vars /\ Fairness

THEOREM Spec => []TypeOK

====