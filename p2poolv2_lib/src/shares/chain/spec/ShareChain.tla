---- MODULE ShareChain ----
EXTENDS Naturals, Sequences, TLC, FiniteSets, Integers

CONSTANTS 
    Processes,      \* Set of processes that generate shares

    MaxShares,      \* Maximum number of shares per process
    Work            \* Work/difficulty parameter for shares

VARIABLES
    shares,         \* Set of all shares across all processes
    chain_tip,      \* Current tip of the chain per process
    seqNo,          \* Sequence number tracker per process
    parent,         \* Parent references for each share
    uncles,         \* Uncle references for each share
    chain_work,     \* Total work accumulated up to each share on each process
    height,         \* Height of each share in the chain at each process
    share_queue     \* Queue of shares that have been generated but not yet sent/received

vars == <<shares, chain_tip, seqNo, share_queue, uncles, parent, chain_work, height>>

Genesis == [process |-> CHOOSE p \in Processes: TRUE, seq |-> 0, work |-> 1]

NoHeight == -1

(****************************************************************************)
(* A share is a tuple containing:                                           *)
(* - process: the generating process                                        *)
(* - seq: sequence number of share generated by this process                *)
(* - work: work/difficulty in the share                                     *)
(****************************************************************************)
Share == [
    process: Processes,
    seq: (0..MaxShares),
    work: Work
]

        
TypeOK ==
    /\ shares \in [Processes -> Share]
    /\ seqNo \in [Processes -> (0..MaxShares)]
    /\ chain_tip \in [Processes -> {Share} \cup {Genesis}]
    /\ parent \in [Share -> Share \cup {Genesis}]
    /\ uncles \in [Share -> Share \cup {Genesis}]
    /\ chain_work \in [Processes \X Share -> Nat]
    /\ height \in [Processes \X Share -> Nat \cup {NoHeight}]
    /\ share_queue \in Seq(Share)

Init ==
    /\ shares = [p \in Processes |-> {Genesis}]  \* All processes start with genesis share
    /\ seqNo = [p \in Processes |-> 0]
    /\ chain_tip = [p \in Processes |-> Genesis]
    /\ parent = [s \in Share \cup {Genesis} |-> {}]
    /\ uncles = [s \in Share \cup {Genesis} |-> {}]
    /\ chain_work = [p \in Processes, s \in Share \cup {Genesis} |-> IF s = Genesis THEN 1 ELSE 0] \* Genesis share has work of 1
    /\ height = [p \in Processes, s \in Share \cup {Genesis} |-> IF s = Genesis THEN 0 ELSE NoHeight] \* Genesis share has height 0
    /\ share_queue = << >>


(****************************************************************************)
(* Get the main chain from tip for process p                                *)
(****************************************************************************)
RECURSIVE MainChain(_, _)
MainChain(p, tip) ==
    IF tip = Genesis THEN {}
    ELSE
        LET parentShare == parent[tip]
        IN  {tip} \cup MainChain(p, parentShare)

(****************************************************************************)
(* Get the chain from tip for process p - including uncles                  *)
(****************************************************************************)
RECURSIVE DAG(_, _)
DAG(p, tip) ==
    IF tip = Genesis THEN {}
    ELSE
        LET parentShare == parent[tip]
        IN  {tip}
            \cup DAG(p, parentShare) 
            \cup {DAG(p, u) : u \in uncles[parentShare]}

(****************************************************************************)
(* Check if two shares have a common ancestor on process p within max uncle *)
(* depth                                                                    *)
(****************************************************************************)
CommonAncestor(p, s1, s2) ==
    \E a \in shares[p] :
        /\ a \in MainChain(p, s1)
        /\ a \in MainChain(p, s2)
        /\ height[p, chain_tip[p]] - height[p, a] >= 3

(****************************************************************************)
(* Get uncles for a share s generated by process p.                         *)
(* Uncles must meet the requirements:                                       *)
(* - Must be present in shares[p]                                           *)
(* - Must not be on the main chain                                          *)
(* - Must be no deeper than 3                                               *)
(* - Must have a common ancestor with the chain tip at p                    *)
(* - Must not already be included as an uncle                               *)
(****************************************************************************)
UnclesFor(p, s) ==
    {u \in shares[p] : 
        /\ u # s
        /\ u # chain_tip[p]
        /\ u \notin MainChain(p, chain_tip[p])
        /\ height[p, s] - height[p, u] <= 3
        /\ CommonAncestor(p, u, chain_tip[p])
        /\ u \notin UNION {uncles[x]: x \in shares[p]} \* u is not an uncle for any share tracked on p
    }

(****************************************************************************)
(* Host process generates a new share                                       *)
(* - Creates a share with the next sequence number and work                 *)
(* - Track parent for the new share as the current chain tip                *)
(* - Update tips to include the new share and remove the chain tip          *)
(* - Increment sequence number for the process                              *)
(****************************************************************************)
GenerateShare(p, work) ==
    /\ Cardinality(shares[p]) < MaxShares \* Limit total shares
    /\ work \in Work
    /\ LET newShare == [
            process |-> p,
            seq |-> seqNo[p] + 1,
            work |-> work
        ]
       IN  \* Add new share to the process's shares
           /\ shares' = [shares EXCEPT ![p] = @ \cup {newShare}]
            \* parent is the current chain tip
           /\ parent' = [parent EXCEPT ![newShare] = chain_tip[p]]
            \* select uncles for the new share
           /\ uncles' = [uncles EXCEPT ![newShare] = UnclesFor(p, newShare)]
            \* When generating a new share, new share always supercedes the current tip - remove chain tip from tips and add new share as a tip
           /\ seqNo' = [seqNo EXCEPT ![p] = @ + 1]
           \* Update chain tip to the new share
           /\ chain_tip' = [chain_tip EXCEPT ![p] = newShare]
           \* The total work for the new share is the previous chain tip's total work plus the new share's work
           /\ chain_work' = [chain_work EXCEPT ![p, newShare] = chain_work[p, chain_tip[p]] + work]
           \* Height is previous chain tip's height plus one
           /\ height' = [height EXCEPT ![p, newShare] = height[p, chain_tip[p]] + 1]
           \* Enqueue the new share for sending to other processes
           /\ share_queue' = Append(share_queue, newShare)

(****************************************************************************)
(* Sum the chain work for a set of shares                                  *)
(****************************************************************************)
RECURSIVE SumWork(_, _)
SumWork(p, shareSet) ==
    IF shareSet = { } THEN 0
    ELSE LET s == CHOOSE x \in shareSet : TRUE
         IN chain_work[p, s] + SumWork(p, shareSet \ {s})

(****************************************************************************)
(* Calculate total work over PPLNS window for process p and share s        *)
(****************************************************************************)
TotalWorkOverPPLNSWindow(p, s) ==
    LET dag == DAG(p, s)
        IN  SumWork(p, dag)

(****************************************************************************)
(* Receive a share from another process                                     *)
(* The receiving node's tips will be changed, the uncles and parent         *)
(* relationships remain unchanged.                                          *)
(****************************************************************************)
ReceiveShare(p) ==
    /\ share_queue # << >>
    /\ LET s == Head(share_queue)
       IN
        \* Add to shares
        /\ shares' = [shares EXCEPT ![p] = @ \cup {s}]
        \* Update height to be parent's height + 1
        /\ height' = [height EXCEPT ![p, s] = height[p, parent[s]] + 1]
        \* Update chain work to be parent's chain work + s.work
        /\ chain_work' = [chain_work EXCEPT ![p, s] = chain_work[p, parent[s]] + s.work]
        /\ IF CommonAncestor(p, s, chain_tip[p]) THEN
            \* New share becomes the new tip if it exceeds current tip's work
            /\ IF chain_work[p, parent[s]] + s.work > chain_work[p, chain_tip[p]] THEN
                /\ chain_tip' = [chain_tip EXCEPT ![p] = s]
                /\ UNCHANGED <<seqNo, parent, uncles >>
                ELSE
                /\ UNCHANGED <<chain_tip, seqNo, parent, uncles>>
          ELSE
            \* For disjoint chains, the new share becomes the tip only if its total work over PPLNS window exceeds current tip's
            /\ IF TotalWorkOverPPLNSWindow(p, s) > TotalWorkOverPPLNSWindow(p, chain_tip[p]) THEN
                /\ chain_tip' = [chain_tip EXCEPT ![p] = s]
                /\ UNCHANGED <<seqNo, parent, uncles >>
               ELSE
                /\ UNCHANGED <<chain_tip, seqNo, parent, uncles>>
    /\ share_queue' = Tail(share_queue)

Next ==
    \/ \E p \in Processes,
        work \in Work : GenerateShare(p, work)
    \/ \E p \in Processes : ReceiveShare(p)

Fairness == WF_vars(\E p \in Processes: ReceiveShare(p))

Spec == Init /\ [][Next]_vars /\ Fairness

THEOREM Spec => []TypeOK

====