---- MODULE ShareChain ----
EXTENDS Naturals, Sequences, TLC, FiniteSets

CONSTANTS 
    Processes,      \* Set of processes that generate shares
    MaxShares,      \* Maximum number of shares per process
    Work            \* Work/difficulty parameter for shares

VARIABLES
    shares,         \* Set of all shares across all processes
    tips,           \* Current tips of the DAG (tip + uncles)
    chain_tip,      \* Current tip of the chain per process
    seqNo,          \* Sequence number tracker per process
    parents,        \* Parent references for each share
    uncles,         \* Uncle references for each share
    chain_work,     \* Total work accumulated up to each share on each process
    share_queue     \* Queue of shares that have been generated but not yet sent/received

Genesis == [process |-> CHOOSE p \in Processes: TRUE, seq |-> 0, work |-> 1]

\* A share is a tuple containing:
\* - process: the generating process
\* - seq: sequence number of share generated by this process
\* - work: work/difficulty in the share
\* - parent: reference to previous share (tip when share was generated)
\* - uncles: set of references to uncle shares
Share == [
    process: Processes,
    seq: (0..MaxShares),
    work: Work
]

        
TypeOK ==
    /\ shares \in [Processes -> Share]
    /\ tips \in [Processes -> Share]
    /\ seqNo \in [Processes -> (0..MaxShares)]
    /\ chain_tip \in [Processes -> {Share} \cup {Genesis}]
    /\ parents \in [Share -> Share \cup {Genesis}]
    /\ uncles \in [Share -> Share \cup {Genesis}]
    /\ chain_work \in [Processes \X Share -> Nat]
    /\ share_queue \in Seq(Share)

Init ==
    /\ shares = [p \in Processes |-> {Genesis}]  \* All processes start with genesis share
    /\ tips = [p \in Processes |-> {Genesis}]
    /\ seqNo = [p \in Processes |-> 0]
    /\ chain_tip = [p \in Processes |-> Genesis]
    /\ parents = [s \in Share \cup {Genesis} |-> {}]
    /\ uncles = [s \in Share \cup {Genesis} |-> {}]
    /\ chain_work = [p \in Processes, s \in Share \cup {Genesis} |-> IF s = Genesis THEN 1 ELSE 0] \* Genesis share has work of 1
    /\ share_queue = << >>

\* Host process generates a new share
\* - Creates a share with the next sequence number and work
\* - Track parent for the new share as the current chain tip
\* - Track uncles as current tips excluding the chain tip
\* - Update tips to include the new share and remove the chain tip
\* - Increment sequence number for the process
GenerateShare(p, work) ==
    /\ Cardinality(shares[p]) < MaxShares \* Limit total shares
    /\ work \in Work
    /\ LET newShare == [
            process |-> p,
            seq |-> seqNo[p] + 1,
            work |-> work
        ]
       IN  /\ shares' = [shares EXCEPT ![p] = @ \cup {newShare}]
            \* parent is obtained as the current chain tip
           /\ parents' = [parents EXCEPT ![newShare] = chain_tip[p]]
            \* uncles are current tips excluding the chain tip
           /\ uncles' = [uncles EXCEPT ![newShare] = (tips[p] \ {chain_tip[p]})]
            \* When generating a new share, new share always supercedes the current tip - remove chain tip from tips and add new share as a tip
           /\ tips' = [tips EXCEPT ![p] = (@ \cup {newShare}) \ {chain_tip[p]}]
           /\ seqNo' = [seqNo EXCEPT ![p] = @ + 1]
           /\ chain_tip' = [chain_tip EXCEPT ![p] = newShare]
           \* The total work for the new share is the previous chain tip's total work plus the new share's work
           /\ chain_work' = [chain_work EXCEPT ![p, newShare] = chain_work[p, chain_tip[p]] + work]
           /\ share_queue' = Append(share_queue, newShare)
           /\ UNCHANGED << >>

\* Receive a share from another process
\* The receiving node's tips will be changed, the uncles and parents relationships remain unchanged.
ReceiveShare ==
    /\ share_queue # << >>
    /\ LET s == Head(share_queue)
       IN
           /\ \A p \in Processes :
               /\ shares' = [shares EXCEPT ![p] = @ \cup {s}]
               /\ IF chain_work[p, parents[s]] + s.work > chain_work[p, chain_tip[p]] THEN
                   /\ chain_tip' = [chain_tip EXCEPT ![p] = s]
                   /\ tips' = [tips EXCEPT ![p] = (@ \cup {s}) \ {chain_tip[p]}]
                   /\ chain_work' = [chain_work EXCEPT ![p, s] = chain_work[p, parents[s]] + s.work]
                   /\ UNCHANGED <<seqNo, parents, uncles>>
                  ELSE
                   /\ UNCHANGED <<chain_tip, tips, chain_work, seqNo, parents, uncles>>
           /\ share_queue' = Tail(share_queue)

Next ==
    \E p \in Processes,
        work \in Work : GenerateShare(p, work)
    \/ ReceiveShare

Spec == Init /\ [][Next]_<<shares, tips, chain_tip, seqNo>>

THEOREM Spec => []TypeOK

====