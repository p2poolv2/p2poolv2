---- MODULE ShareChain ----
EXTENDS Naturals, Sequences, TLC, FiniteSets, Integers, SequencesExt

CONSTANTS 
    Processes,                  \* Set of processes that generate shares
    MaxShares,                  \* Maximum number of shares per process
    Work,                       \* Work/difficulty parameter for shares
    MaxUnclesDepth,             \* Maximum depth for uncles included in a share
    MaxBitcoinHeight            \* Current Bitcoin network height for validating received shares

VARIABLES
    shares,                     \* Set of all shares across all processes
    parent,                     \* Parent references for each share
    uncles,                     \* Uncle references for each share
    confirmed_work,             \* Total work accumulated up to each confirmed height on each process
    candidate_work,             \* Total work accumulated up to each candidate height, if any
    confirmed_height,           \* confirmed_height of each share in the chain at each process
    candidate_uncles_height,     \* candidate uncles height of each share in the chain at each process
    confirmed_uncles_height,    \* confirmed uncles height of each share in the chain at each process
    candidate_height,           \* candidate_height of each share in the chain at each process
    received_shares,            \* Set of shares received from other processes, but not validated yet
    validation_status,          \* Validation status of received shares
    share_queue,                \* Queue of shares that have been generated but not yet sent/received,
    bitcoin_height,              \* Bitcoin network height associated with each share
    spend_dependencies          \* Dependency Share -> Share. The key share is spending the value share.
vars == <<shares, share_queue, uncles, parent, confirmed_work, bitcoin_height, confirmed_height, candidate_height, received_shares, validation_status, spend_dependencies>>

(****************************************************************************)
(* Genesis share definition                                                *)
(****************************************************************************)

Genesis == [process |-> CHOOSE p \in Processes: TRUE, work |-> 1, bitcoin_height |-> 0]

\* Use NoHeight to indicate share not found in height sequences, aligns with sequence indexed from 1
NoHeight == 0

TotalShares == MaxShares * Cardinality(Processes)

\* Genesis height is 1, aligns with sequence indexed from 1
Height == (1..TotalShares)

(****************************************************************************)
(* A share is a tuple containing:                                           *)
(* - process: the generating process                                        *)
(* - seq: sequence number of share generated by this process                *)
(* - work: work/difficulty in the share                                     *)
(****************************************************************************)
Share == [
    process: Processes,
    work: Work,
    bitcoin_height: (-1..MaxBitcoinHeight)
]

NoShare == [process |-> CHOOSE p \in Processes: TRUE, work |-> 0, bitcoin_height |-> -1]
        
TypeOK ==
    /\ shares \in [Processes -> Share]
    /\ parent \in [Share -> Share \cup {Genesis} \cup {NoShare}]
    /\ uncles \in [Share -> Share \cup {Genesis} \cup {NoShare}]
    /\ confirmed_work \in [Processes \X (Share \cup {Genesis}) -> Nat]
    /\ candidate_work \in [Processes \X (Share \cup {Genesis}) -> Nat]
    /\ confirmed_height \in [Processes -> Seq(Share)]
    /\ candidate_height \in [Processes -> Seq(Share)]
    /\ confirmed_uncles_height \in [Processes -> Seq(SUBSET Share)]
    /\ candidate_uncles_height \in [Processes -> Seq(SUBSET Share)]
    /\ received_shares \in [Processes -> Seq(Share)]
    /\ validation_status \in [Processes \X Share -> {"None", "Pending", "Valid", "Invalid"}]
    /\ share_queue \in Seq(Share)
    /\ bitcoin_height \in [Processes -> (0..MaxBitcoinHeight)]
    /\ spend_dependencies \in [Share -> SUBSET Share]

Init ==
    /\ shares = [p \in Processes |-> {Genesis}]  \* All processes start with genesis share
    /\ parent = [s \in Share \cup {Genesis} |-> NoShare]
    /\ uncles = [s \in Share \cup {Genesis} |-> {}]
    /\ confirmed_work = [p \in Processes, s \in (Share \cup {Genesis}) |-> IF s = Genesis THEN 1 ELSE 0] \* Genesis share has work of 1
    /\ candidate_work = [p \in Processes, s \in (Share \cup {Genesis}) |-> 0] \* Candidate chain is empty at the start
    /\ confirmed_height = [p \in Processes |->  << Genesis >> ] \* Genesis at height 0
    /\ candidate_height = [p \in Processes |-> << >> ] \* Empty
    /\ confirmed_uncles_height = [p \in Processes |-> << >> ] \* Empty
    /\ candidate_uncles_height = [p \in Processes |-> << >> ] \* Empty
    /\ received_shares = [p \in Processes |-> << >>]
    /\ validation_status = [p \in Processes, s \in Share |-> "None"]
    /\ bitcoin_height = [p \in Processes |-> 0]
    /\ share_queue = << >>
    /\ spend_dependencies = [s \in Share |-> {}]

(****************************************************************************)
(* Get the candidate top height for process p                              *)
(****************************************************************************)
TopConfirmed(p) ==
    confirmed_height[p][Len(confirmed_height[p])]

(****************************************************************************)
(* Get the penultimate confirmed height for process p                       *)
(****************************************************************************)
PenultimateConfirmed(p) ==
    confirmed_height[p][Len(confirmed_height[p]) - 1]

(****************************************************************************)
(* Get the candidate top height for process p                              *)
(****************************************************************************)
TopCandidate(p) ==
    IF Len(candidate_height[p]) = 0 THEN NoShare
    ELSE
    candidate_height[p][Len(candidate_height[p])]

(****************************************************************************)
(* Get the penultimate candidate height for process p                       *)
(****************************************************************************)
PenultimateCandidate(p) ==
    candidate_height[p][Len(candidate_height[p]) - 1]

(****************************************************************************)
(* Get the candidate height of a share s on process p                       *)
(* returns NoHeight if not found                                            *)
(* In implementaion we replace these scans with more efficient              *)
(* indexing of heights stored as "expected height derived from parent"      *)
(****************************************************************************)
GetCandidateHeight(p, s) ==
    SelectInSeq(candidate_height[p], LAMBDA v: v = s)

(****************************************************************************)
(* Get the confirmed height of a share s on process p                       *)
(* returns NoHeight if not found                                            *)
(* In implementaion we replace these scans with more efficient              *)
(* indexing of heights stored as "expected height derived from parent"      *)
(****************************************************************************)
GetConfirmedHeight(p, s) ==
    SelectInSeq(confirmed_height[p], LAMBDA v: v = s)

(****************************************************************************)
(* Get the chain starting from given share for process p                    *)
(****************************************************************************)
RECURSIVE ChainFromShare(_, _)
ChainFromShare(p, s) ==
    IF s = Genesis THEN {}
    ELSE
        LET parentShare == parent[s]
        IN  {s} \cup ChainFromShare(p, parentShare)

(****************************************************************************)
(* Get the chain from share for process p - including uncles                *)
(****************************************************************************)
RECURSIVE DAG(_, _)
DAG(p, s) ==
    IF s = Genesis THEN {}
    ELSE
        LET parentShare == parent[s]
        IN  {s}
            \cup DAG(p, parentShare) 
            \cup {DAG(p, u) : u \in uncles[parentShare]}

(****************************************************************************)
(* Get the chain from share for process p - including uncles                *)
(****************************************************************************)
RECURSIVE DAGBetween(_, _, _)
DAGBetween(p, s, t) ==
    IF \/ t = Genesis
       \/ s = t THEN {}
    ELSE
        LET parentShare == parent[t]
        IN  {t}
            \cup DAGBetween(p, s, parentShare) 
            \cup {DAGBetween(p, s, u) : u \in uncles[parentShare]}

(****************************************************************************)
(* Check if two shares have a common ancestor on process p within max uncle *)
(* depth                                                                    *)
(****************************************************************************)
ConfirmedCommonAncestorWithinRange(p, s1, s2) ==
    \E a \in shares[p] :
        /\ a \in ChainFromShare(p, s1)
        /\ a \in ChainFromShare(p, s2)
        /\ confirmed_height[p, a] # NoHeight
        /\ confirmed_height[p, TopConfirmed(p)] - confirmed_height[p, a] >= MaxUnclesDepth

(****************************************************************************)
(* Check if two shares have a common ancestor on process p                  *)
(****************************************************************************)
ConfirmedCommonAncestor(p, s1, s2) ==
    \E a \in shares[p] :
        /\ a \in ChainFromShare(p, s1)
        /\ a \in ChainFromShare(p, s2)
        /\ confirmed_height[p, a] # NoHeight

(****************************************************************************)
(* Recursively collect uncles from highest to lowest height, limiting to 3  *)
(****************************************************************************)
RECURSIVE CollectUncles(_, _, _, _, _)
CollectUncles(p, h, min_h, collected, over) ==
    IF h < min_h \/ Cardinality(collected) >= 3 THEN collected
    ELSE
    LET remaining == 3 - Cardinality(collected)
        uncles_at_h == over[p][h]
        \* Filter out shares that are already uncles in the range
        valid_uncles == {u \in uncles_at_h : 
            \A height \in min_h..h : u \notin uncles[p][height]}
        to_add == IF Cardinality(valid_uncles) <= remaining 
                THEN valid_uncles 
                ELSE CHOOSE subset \in SUBSET valid_uncles : Cardinality(subset) = remaining
    IN CollectUncles(p, h - 1, min_h, collected \cup to_add, over)

(****************************************************************************)
(* Get uncles for a share s generated by process p.                         *)
(* Find all uncles in confirmed uncles height with height between parent    *)
(* height - 3 and parent height                                             *)
(****************************************************************************)
ConfirmedUnclesFor(p, s) ==
    LET parent_height == GetConfirmedHeight(p, parent[s])
        min_height == IF parent_height > 3 THEN parent_height - 3 ELSE 1
        IN CollectUncles(p, parent_height, min_height, {}, confirmed_uncles_height)

(****************************************************************************)
(* Get uncles for a share s generated by process p from candidate chain.    *)
(* Find all uncles in candidate uncles height with height between parent    *)
(* height - 3 and parent height                                             *)
(****************************************************************************)
CandidateUnclesFor(p, s) ==
    LET parent_height == GetCandidateHeight(p, parent[s])
        min_height == IF parent_height > 3 THEN parent_height - 3 ELSE 1
        IN CollectUncles(p, parent_height, min_height, {}, candidate_uncles_height)

(****************************************************************************)
(* Push a share s onto the candidate chain for process p                    *)
(* - candidate_height is parent's candidate_height + 1                      *)
(* - candidate_work is parent's candidate_work + s.work                     *)
(****************************************************************************)
PushToCandidate(p, s) ==
    \* Push only if parent is at the top of candidate
    /\ parent[s] = TopCandidate(p)
    /\
        LET parentShare == parent[s]
            parent_work == IF parentShare = NoShare \/ parentShare = Genesis THEN 1 ELSE candidate_work[p, parentShare]
        IN
            /\ candidate_height' = 
                [candidate_height EXCEPT ![p] = Append(@, s)]
            /\ candidate_work' = 
                [candidate_work EXCEPT ![p, s] = parent_work + s.work]

(****************************************************************************)
(* Push a share s onto the candidate uncles for process p                   *)
(* - candidate_uncles_height is parent's candidate_height + 1               *)
(****************************************************************************)
PushToCandidateUncles(p, s) ==
    \* Push only if parent is not at the top of candidate
    /\ parent[s] # TopCandidate(p)
    \* Parent must be in candidate height
    /\ GetCandidateHeight(p, parent[s]) # NoHeight
    \* Parent must be no deeper than 3 from candidate top
    /\ Len(candidate_height[p]) - GetCandidateHeight(p, parent[s]) <= 3
    /\
        LET parentShare == parent[s]
            parent_height == GetCandidateHeight(p, parentShare)
        IN  
            /\ candidate_uncles_height' = 
                [candidate_uncles_height EXCEPT ![p][parent_height + 1] = @ \cup {s}]
            /\ candidate_work' = 
                [candidate_work EXCEPT ![p, s] = candidate_work[p, parentShare] + s.work]

(****************************************************************************)
(* Push a share s onto the confirmed chain for process p                    *)
(* - confirmed_height is parent's confirmed_height + 1                      *)
(* - confirmed_work is parent's confirmed_work + s.work                     *)
(****************************************************************************)
PushToConfirmed(p, s) ==
    \* Push only if parent is at the top of confirmed
    \* /\ parent[s] = TopConfirmed(p)
    /\
        LET parentShare == parent[s]
            parent_work == IF parentShare = NoShare \/ parentShare = Genesis THEN 1 ELSE confirmed_work[p, parentShare]
        IN
            /\ confirmed_height' = 
                [confirmed_height EXCEPT ![p] = Append(@, s)]
            /\ confirmed_work' = 
                [confirmed_work EXCEPT ![p, s] = parent_work + s.work]

(****************************************************************************)
(* Push a share s onto the confirmed uncles for process p                   *)
(* - confirmed_uncles_height is parent's confirmed_height + 1               *)
(****************************************************************************)
PushToConfirmedUncles(p, s) ==
    \* Push only if parent is not at the top of confirmed
    /\ parent[s] # TopConfirmed(p)
    \* Parent must be in confirmed height
    /\ GetConfirmedHeight(p, parent[s]) # NoHeight
    \* Parent must be no deeper than 3 from confirmed top
    /\ Len(confirmed_height[p]) - GetConfirmedHeight(p, parent[s]) <= 3
    /\
        LET parentShare == parent[s]
            parent_height == GetConfirmedHeight(p, parentShare)
        IN  
            /\ confirmed_uncles_height' = 
                [confirmed_uncles_height EXCEPT ![p][parent_height + 1] = @ \cup {s}]
            /\ confirmed_work' = 
                [confirmed_work EXCEPT ![p, s] = confirmed_work[p, parentShare] + s.work]

(****************************************************************************)
(* Host process generates a new share                                       *)
(* - Creates a share with some work                                         *)
(* - Track parent for the new share as the current chain tip                *)
(* - Update tips to include the new share and remove the chain tip          *)
(****************************************************************************)
GenerateShare(p, work) ==
    /\ Cardinality(shares[p]) < MaxShares \* Limit total shares
    /\ Len(confirmed_height[p]) > 0 \* Ensure genesis is present
    /\ work \in Work
    /\ LET
        bitcoin_height_p == CHOOSE h \in (0..MaxBitcoinHeight) : h > bitcoin_height[p]
        newShare == [
            process |-> p,
            work |-> work,
            bitcoin_height |-> bitcoin_height_p
        ]
       IN  \* Add new share to the process's shares
           /\ shares' = [shares EXCEPT ![p] = @ \cup {newShare}]
            \* parent is the current chain tip
           /\ parent' = [parent EXCEPT ![newShare] = TopConfirmed(p)]
            \* Immediately confirm the new share
           /\ confirmed_height' = 
                [confirmed_height EXCEPT ![p] = Append(@, newShare)]
            \* Update confirmed work as parent's work + new share's work
           /\ confirmed_work' = 
                [confirmed_work EXCEPT ![p, newShare] = confirmed_work[p, TopConfirmed(p)] + work]
            \* select uncles for the new share
           /\ uncles' = [uncles EXCEPT ![newShare] = ConfirmedUnclesFor(p, newShare)]
           \* Enqueue the new share for sending to other processes
           /\ share_queue' = Append(share_queue, newShare)
           \* Set bitcoin height for the new share, it can be any valid height
           /\ bitcoin_height' = [bitcoin_height EXCEPT ![p] = bitcoin_height_p + 1]
           /\ UNCHANGED << received_shares, candidate_height, validation_status, spend_dependencies, candidate_work, confirmed_uncles_height, candidate_uncles_height>>

(****************************************************************************)
(* Sum the chain work for a set of shares                                  *)
(****************************************************************************)
RECURSIVE SumWork(_, _)
SumWork(p, shareSet) ==
    IF shareSet = { } THEN 0
    ELSE LET s == CHOOSE x \in shareSet : TRUE
         IN confirmed_work[p, s] + SumWork(p, shareSet \ {s})

(****************************************************************************)
(* Calculate total work over PPLNS window for process p and share s        *)
(****************************************************************************)
TotalWorkOverPPLNSWindow(p, s) ==
    LET dag == DAG(p, s)
        IN  SumWork(p, dag)

(****************************************************************************)
(* Receive a share on process p                                             *)
(* The share is added to the shares set, but not  made candidate or         *)
(* confirmed yet                                                            *)
(****************************************************************************)
ReceiveShare(p) ==
    /\ share_queue # << >>
    /\ LET s == Head(share_queue)
       IN
        /\ \/ Contains(received_shares[p], s) # TRUE \* Only process share if not already received
           \/ s \notin shares[p] \* Only process share if not already present in stored shares
        /\ bitcoin_height[p] - s.bitcoin_height <= 1 \* Share should be recent enough
        \* Add to received shares
        /\ received_shares' = [received_shares EXCEPT ![p] = Append(@, s)]
    /\ share_queue' = Tail(share_queue)
    /\ UNCHANGED << parent, uncles, confirmed_work, confirmed_height, candidate_height, bitcoin_height, validation_status, shares, spend_dependencies, candidate_work, confirmed_uncles_height, candidate_uncles_height >>


(****************************************************************************)
(* Validate a received share so it can be confirmed later                   *)
(* Validation is indepdent of parent's status                               *)
(* We could get into modeling txs, but that is not relevant to chain        *)
(* organisation                                                             *)
(****************************************************************************)
ValidateShare(p) ==
    /\ received_shares[p] # << >>
    /\ LET s == Head(received_shares[p])
       IN
        /\ \/ validation_status[p, s] = "None"
           \/ validation_status[p, s] = "Pending" 
        /\ validation_status' = [validation_status EXCEPT ![p, s] = "Valid"]
    /\ UNCHANGED << shares, parent, uncles, confirmed_work, confirmed_height, candidate_height, bitcoin_height, received_shares, share_queue, spend_dependencies, candidate_work, confirmed_uncles_height, candidate_uncles_height >>

(****************************************************************************)
(* Make a received share into a candidate share                             *)
(* - parent has to be a candidate or confirmed share                        *)
(* - candidate_height is parent's candidate_height + 1                      *)
(****************************************************************************)
MakeShareCandidate(p) == 
    /\ received_shares[p] # << >>
    /\ LET s == Head(received_shares[p])
           candidate_height_s == GetCandidateHeight(p, parent[s])
           confirmed_height_s == GetConfirmedHeight(p, parent[s])
       IN
        /\ \/ candidate_height_s # NoHeight
           \/ confirmed_height_s # NoHeight
        /\ validation_status[p, s] = "Valid"
        /\ PushToCandidate(p, s)
        /\ received_shares' = [received_shares EXCEPT ![p] = Tail(@)]
    /\ UNCHANGED << shares, parent, uncles, confirmed_work, confirmed_height, bitcoin_height, share_queue, validation_status, spend_dependencies, confirmed_uncles_height, candidate_uncles_height >>

(****************************************************************************)
(* Mark a share as confirmed on process p                                   *)
(* Preconditions:                                                           *)
(* - parent should be confirmed                                             *)
(* - identify fork point                                                    *)
(* - all spend dependencies should be confirmable all the way to this share *) 
(*   from fork point                                                        *)
(* - candidate chain up to this share should be longer than confirmed chain *)
(* Changes:                                                                 *)
(*   - unconfirm all above the fork point in confirmed chain                *)
(*   - confirm all in the candidate chain up to this share                  *)
(* We avoid having to check for spending dependencies by following the      *)
(* libbitcoin pop, then push protocol                                       *)
(****************************************************************************)
\* ConfirmCandidates(p, s) ==
\*     /\

(****************************************************************************)
(* Unconfirm all shares between top and bottom inclusive                    *)
(* The shares from top to bottom should all be confirmed in sequence        *)
(* The above says they form a consecytive DAG                               *)
(****************************************************************************)
\* UnconfirmRange(p, top, bottom) ==
\*     /\ confirmed_height[p, top] > confirmed_height[p, bottom]       \* top height > bottom height
\*     /\ bottom \in DAG(p, top) \* DAG from top to genesis has bottom in it
\*     /\ \A s \in DAGBetween(p, top, bottom): 
\*             confirmed_height' = [confirmed_height EXCEPT ![p, s] = NoHeight]
\*     /\ UNCHANGED << shares, parent, uncles, confirmed_work, bitcoin_height, share_queue, validation_status, spend_dependencies, validation_status, received_shares >>


(****************************************************************************)
(* Confirm a share on process p                                             *)
(* The receiving node's tips will be changed, the uncles and parent         *)
(* relationships remain unchanged.                                          *)
(****************************************************************************)
\* ConfirmShare(p) ==
\*     /\ share_queue # << >>
\*     /\ LET s == Head(share_queue)
\*        IN
\*         /\ s \notin shares[p] \* Only process share if not already present
\*         /\ bitcoin_height[p] - s.bitcoin_height <= 1 \* Share should be recent enough
\*         \* Add to shares
\*         /\ shares' = [shares EXCEPT ![p] = @ \cup {s}]
\*         \* Update confirmed_height to be parent's confirmed_height + 1
\*         /\ confirmed_height' = [confirmed_height EXCEPT ![p, s] = confirmed_height[p, parent[s]] + 1]
\*         \* Update chain work to be parent's chain work + s.work
\*         /\ confirmed_work' = [confirmed_work EXCEPT ![p, s] = confirmed_work[p, parent[s]] + s.work]
\*         /\ IF ConfirmedCommonAncestor(p, s, chain_tip[p]) THEN
\*             \* New share becomes the new tip if it exceeds current tip's work
\*             /\ IF confirmed_work[p, parent[s]] + s.work > confirmed_work[p, chain_tip[p]] THEN
\*                 /\ chain_tip' = [chain_tip EXCEPT ![p] = s]
\*                 /\ UNCHANGED <<parent, uncles, bitcoin_height, received_shares, candidate_height, validation_status, spend_dependencies>>
\*                 ELSE
\*                 /\ UNCHANGED <<chain_tip, parent, uncles, bitcoin_height, received_shares, candidate_height, validation_status, spend_dependencies>>
\*           ELSE
\*             \* For disjoint chains, the new share becomes the tip only if its total work over PPLNS window exceeds current tip's
\*             /\ IF TotalWorkOverPPLNSWindow(p, s) > TotalWorkOverPPLNSWindow(p, chain_tip[p]) THEN
\*                 /\ chain_tip' = [chain_tip EXCEPT ![p] = s]
\*                 /\ UNCHANGED <<parent, uncles, bitcoin_height, received_shares, candidate_height, validation_status, spend_dependencies>>
\*                ELSE
\*                 /\ UNCHANGED <<chain_tip, parent, uncles, bitcoin_height, received_shares, candidate_height, validation_status, spend_dependencies>>
\*     /\ share_queue' = Tail(share_queue)

Next ==
    \/ \E p \in Processes,
        work \in Work : GenerateShare(p, work)
    \/ \E p \in Processes : ReceiveShare(p)
    \/ \E p \in Processes : ValidateShare(p)
    \/ \E p \in Processes : MakeShareCandidate(p)
    \* \/ \E p \in Processes : ConfirmShare(p)

Fairness == 
    /\ WF_vars(\E p \in Processes: ReceiveShare(p))
    /\ WF_vars(\E p \in Processes: ValidateShare(p))
    /\ SF_vars(\E p \in Processes: received_shares[p] # << >> => ValidateShare(p))
    /\ SF_vars(\E p \in Processes: (\E s \in Share: validation_status[p, s] = "Valid") => MakeShareCandidate(p))
    /\ WF_vars(\E p \in Processes: MakeShareCandidate(p))
    \* /\ WF_vars(\E p \in Processes: ConfirmShare(p))

Spec == Init /\ [][Next]_vars /\ Fairness

THEOREM Spec => []TypeOK

====