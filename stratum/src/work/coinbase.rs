// Copyright (C) 2024, 2025 P2Poolv2 Developers (see AUTHORS)
//
// This file is part of P2Poolv2
//
// P2Poolv2 is free software: you can redistribute it and/or modify it under
// the terms of the GNU General Public License as published by the Free
// Software Foundation, either version 3 of the License, or (at your option)
// any later version.
//
// P2Poolv2 is distributed in the hope that it will be useful, but WITHOUT ANY
// WARRANTY; without even the implied warranty of MERCHANTABILITY or FITNESS
// FOR A PARTICULAR PURPOSE. See the GNU General Public License for more details.
//
// You should have received a copy of the GNU General Public License along with
// P2Poolv2. If not, see <https://www.gnu.org/licenses/>.

use crate::session::{EXTRANONCE1_SIZE, EXTRANONCE2_SIZE};
use crate::work::error::WorkError;
use bitcoin::absolute::LockTime;
use bitcoin::blockdata::script::{Builder, ScriptBuf};
use bitcoin::consensus::serialize;
use bitcoin::hashes::{Hash, sha256d};
use bitcoin::network::Network;
use bitcoin::script::PushBytesBuf;
use bitcoin::transaction::{Sequence, Transaction, TxIn, TxOut, Version};
use bitcoin::{Address, Amount};
use p2poolv2_accounting::OutputPair;
use std::str::FromStr;

#[allow(dead_code)]
const EXTRANONCE_SEPARATOR: [u8; EXTRANONCE1_SIZE + EXTRANONCE2_SIZE] =
    [1u8; EXTRANONCE1_SIZE + EXTRANONCE2_SIZE];

const POOL_SIGNATURE: [u8; 8] = *b"P2Poolv2";

// Parse Address from a string provided by the miner
#[allow(dead_code)]
pub fn parse_address(address: &str, network: Network) -> Result<Address, WorkError> {
    let parsed_address = Address::from_str(address).map_err(|e| WorkError {
        message: format!("Invalid address: {e}"),
    })?;

    parsed_address
        .require_network(network)
        .map_err(|_| WorkError {
            message: format!("Address does not match network: {network}"),
        })
}

/// Get current timestamp, in seconds and nanoseconds.
#[allow(dead_code)]
fn get_current_timestamp_bytes() -> (u32, u32) {
    let timestamp = std::time::SystemTime::now()
        .duration_since(std::time::UNIX_EPOCH)
        .unwrap();
    (timestamp.as_secs() as u32, timestamp.subsec_nanos())
}

/// Build outputs for the transaction from the provided address and value and pairs.
#[allow(dead_code)]
fn build_outputs(output_data: &[OutputPair]) -> Vec<TxOut> {
    output_data
        .iter()
        .map(|pair| TxOut {
            value: pair.amount,
            script_pubkey: pair.address.script_pubkey(),
        })
        .collect()
}

/// Append the default witness commitment to the outputs if one is provided.
#[allow(dead_code)]
fn append_default_witness_commitment(
    outputs: &mut Vec<TxOut>,
    default_witness_commitment: Option<String>,
) -> Result<(), WorkError> {
    if let Some(default_witness_commitment) = default_witness_commitment {
        let commitment_bytes = hex::decode(&default_witness_commitment).map_err(|e| WorkError {
            message: format!("Invalid witness commitment hex: {e}"),
        })?;
        let commitment = ScriptBuf::from(commitment_bytes);
        outputs.push(TxOut {
            value: Amount::ZERO,
            script_pubkey: commitment,
        });
    }
    Ok(())
}

/// Build a coinbase from the provided address, network and height.
/// This handles a single address for now - i.e. for solo mining.
/// TODO: Handle multiple addresses and payout proportions.
///
/// Example of a coinbase transaction:
/// coinbase generated by ckpool for regtest four txns
/// [2025-05-23 07:11:04.762] Coinb1: 01000000010000000000000000000000000000000000000000000000000000000000000000ffffffff2d02fa0100046803306804eba96d2d0c
/// [2025-05-23 07:11:04.762] Coinb2: 0a636b706f6f6c0a2f7032706f6f6c76322fffffffff034f2d822400000000
/// [2025-05-23 07:11:04.762] Header: 2000000065a7ea67c8083743a195e7ec5b424bdca660573756eab19968460fbf5e9a18370000000000000000000000000000000000000000000000000000000000000000683003
/// 68207fffff000000000000008000000000000000000000000000000000000000000000000000000000
///
/// Coinbase1:
/// 01000000010000000000000000000000000000000000000000000000000000000000000000ffffffff - standard header for single output coinbase
/// 2d - script length
/// 02fa01 - height
/// 00 - empty flags
/// 04 68033068 - timestamp seconds
/// 04 eba96d2d - enonce1 from tv_nsec ??
/// 0c - 12, the length of the two nonces put together
#[allow(dead_code)]
pub fn build_coinbase_transaction(
    version: Version,
    output_data: &[OutputPair],
    height: i64,
    aux_flags: PushBytesBuf,
    default_witness_commitment: Option<String>,
) -> Result<Transaction, WorkError> {
    if output_data.is_empty() {
        return Err(WorkError {
            message: "Empty output distribution".to_string(),
        });
    }
    // Use timestamp for providing randomness to distribute search space along with enonce1 that will be used by the miners.
    let (secs, nsecs) = get_current_timestamp_bytes();

    let coinbase_script = Builder::new()
        .push_int(height)
        // ckpool pushes just bytes. The spec recommends using PUSH opcodes, so we do that.
        // resuling in us geting 0x0100 instead of ck's 0x00 for flags in the serialized script.
        .push_slice(aux_flags)
        .push_slice(secs.to_le_bytes())
        .push_slice(nsecs.to_le_bytes())
        .push_slice(EXTRANONCE_SEPARATOR)
        .push_slice(POOL_SIGNATURE)
        .into_script();

    let mut outputs = build_outputs(output_data);
    append_default_witness_commitment(&mut outputs, default_witness_commitment)?;

    let coinbase_tx = Transaction {
        version,
        lock_time: LockTime::ZERO,
        input: vec![TxIn {
            previous_output: bitcoin::OutPoint {
                txid: sha256d::Hash::all_zeros().into(),
                vout: u32::MAX,
            },
            script_sig: coinbase_script,
            sequence: Sequence::MAX,
            witness: Vec::<Vec<u8>>::new().into(),
        }],
        output: outputs,
    };
    Ok(coinbase_tx)
}

/// Splits the coinbase transaction into two parts: coinbase1 and coinbase2, separated by our
/// extranonce2 separator.
#[allow(dead_code)]
pub fn split_coinbase(coinbase: &Transaction) -> Result<(String, String), WorkError> {
    let deserialized_coinbase = serialize::<Transaction>(coinbase);
    let separator_pos = match deserialized_coinbase
        .as_slice()
        .windows(EXTRANONCE1_SIZE + EXTRANONCE2_SIZE)
        .position(|window| window == EXTRANONCE_SEPARATOR)
    {
        Some(pos) => pos,
        None => {
            return Err(WorkError {
                message: "Invalid coinbase transaction".to_string(),
            });
        }
    };

    let coinbase1 = hex::encode(&deserialized_coinbase[..separator_pos]);
    let coinbase2 = hex::encode(
        &deserialized_coinbase[separator_pos + (EXTRANONCE1_SIZE + EXTRANONCE2_SIZE)..],
    );
    Ok((coinbase1, coinbase2))
}

#[cfg(test)]
mod tests {
    use bitcoin::hex::DisplayHex;

    use super::*;
    use crate::work::gbt::BlockTemplate;
    use std::fs;

    #[test]
    fn test_parse_address_valid_mainnet() {
        let addr = "1HpRF3JgafxaqjhMEjLNbevpRVvAp15t3A";
        let result = parse_address(addr, Network::Bitcoin);
        assert!(result.is_ok());
    }

    #[test]
    fn test_parse_address_valid_testnet() {
        let addr = "tb1q0afww6y0kgl4tyjjyv6xlttvfwdfqxvrfzz35f";
        let result = parse_address(addr, Network::Testnet);
        assert!(result.is_ok());
    }

    #[test]
    fn test_parse_address_invalid_format() {
        let addr = "not_a_valid_address";
        let result = parse_address(addr, Network::Bitcoin);
        assert!(result.is_err());
        assert!(
            result
                .err()
                .unwrap()
                .to_string()
                .contains("Invalid address")
        );
    }

    #[test]
    fn test_parse_address_wrong_network() {
        // This is a mainnet address, but we require testnet
        let addr = "1HpRF3JgafxaqjhMEjLNbevpRVvAp15t3A";
        let result = parse_address(addr, Network::Testnet);
        assert!(result.is_err());
        let msg = result.err().unwrap().to_string();
        assert!(msg.contains("Address does not match network"));
        assert!(msg.contains("testnet"));
    }

    #[test]
    fn test_build_coinbase_transaction_without_default_witness() {
        let addr = parse_address(
            "1HpRF3JgafxaqjhMEjLNbevpRVvAp15t3A",
            bitcoin::Network::Bitcoin,
        )
        .unwrap();
        let value = Amount::from_str("50 BTC").unwrap();
        let height = 100;
        let coinbase = build_coinbase_transaction(
            Version(2),
            &[OutputPair {
                address: addr.clone(),
                amount: value,
            }],
            height,
            PushBytesBuf::from(&[0u8]),
            None,
        )
        .unwrap();

        // Check version and lock_time
        assert_eq!(coinbase.version, Version(2));
        assert_eq!(coinbase.lock_time, LockTime::ZERO);

        // Check input
        assert_eq!(coinbase.input.len(), 1);
        let input = &coinbase.input[0];
        assert_eq!(
            input.previous_output.txid,
            sha256d::Hash::all_zeros().into()
        );
        assert_eq!(input.previous_output.vout, u32::MAX);
        assert_eq!(input.sequence, Sequence::MAX);

        let script_bytes = input.script_sig.as_bytes();
        // Check coinbase script contains height
        assert!(script_bytes.contains(&(height as u8)));
        // Check coinbase script contains extranonce separator
        assert!(
            script_bytes
                .windows(EXTRANONCE1_SIZE + EXTRANONCE2_SIZE)
                .any(|w| w == EXTRANONCE_SEPARATOR)
        );

        // Check output
        assert_eq!(coinbase.output.len(), 1);
        let output = &coinbase.output[0];
        assert_eq!(output.value, value);
        assert_eq!(output.script_pubkey, addr.script_pubkey());
    }

    #[test]
    fn test_split_coinbase_without_default_commitment() {
        let addr = parse_address(
            "1HpRF3JgafxaqjhMEjLNbevpRVvAp15t3A",
            bitcoin::Network::Bitcoin,
        )
        .unwrap();
        let value = Amount::from_str("50 BTC").unwrap();
        let height = 100;
        let coinbase = build_coinbase_transaction(
            Version(2),
            &[OutputPair {
                address: addr.clone(),
                amount: value,
            }],
            height,
            PushBytesBuf::from(&[0u8]),
            None,
        )
        .unwrap();

        let (coinbase1, coinbase2) = split_coinbase(&coinbase).unwrap();

        // Reconstruct the coinbase by concatenating coinbase1, extranonce2, and coinbase2
        let extranonce2 = EXTRANONCE_SEPARATOR.to_vec();
        let coinbase1_bytes = hex::decode(&coinbase1).unwrap();
        let coinbase2_bytes = hex::decode(&coinbase2).unwrap();

        let mut reconstructed = Vec::new();
        reconstructed.extend_from_slice(&coinbase1_bytes);
        reconstructed.extend_from_slice(&extranonce2);
        reconstructed.extend_from_slice(&coinbase2_bytes);

        let reconstructed_coinbase: Transaction =
            bitcoin::consensus::deserialize(&reconstructed).unwrap();
        assert_eq!(reconstructed_coinbase, coinbase);
    }

    #[test]
    fn test_building_coinbase_with_regtest_ckpool_data() {
        // Load GBT and expected notify JSON
        let gbt_path = std::path::Path::new(env!("CARGO_MANIFEST_DIR"))
            .join("../tests/test_data/gbt/regtest/ckpool/four-txns/gbt.json");
        let data = fs::read_to_string(gbt_path).expect("Unable to read file");
        let template: BlockTemplate = serde_json::from_str(&data).expect("Invalid JSON");

        let notify_path = std::path::Path::new(env!("CARGO_MANIFEST_DIR"))
            .join("../tests/test_data/gbt/regtest/ckpool/four-txns/notify.json");
        let data = fs::read_to_string(notify_path).expect("Unable to read file");
        let _notify: serde_json::Value = serde_json::from_str(&data).expect("Invalid JSON");

        // Address used in ckpool regtest conf
        let address = parse_address(
            "bcrt1qe2qaq0e8qlp425pxytrakala7725dynwhknufr",
            bitcoin::Network::Regtest,
        )
        .unwrap();

        let donation_address = parse_address(
            "bcrt1qlk935ze2fsu86zjp395uvtegztrkaezawxx0wf",
            bitcoin::Network::Regtest,
        )
        .unwrap();

        let coinbase = build_coinbase_transaction(
            Version(1), // ckpool uses version 1
            &[
                OutputPair {
                    address: address.clone(),
                    amount: Amount::from_str("49 BTC").unwrap(),
                },
                OutputPair {
                    address: donation_address.clone(),
                    amount: Amount::from_str("1 BTC").unwrap(), // ckpool uses 2% donation address. We replicate that for test.
                },
            ],
            template.height as i64,
            PushBytesBuf::from(&[0u8]),
            template.default_witness_commitment.clone(),
        )
        .unwrap();

        assert_eq!(coinbase.version, Version(1));
        assert_eq!(coinbase.lock_time, LockTime::ZERO);
        assert_eq!(coinbase.input.len(), 1);
        let input = &coinbase.input[0];
        assert_eq!(
            input.previous_output.txid,
            sha256d::Hash::all_zeros().into()
        );
        assert_eq!(input.previous_output.vout, u32::MAX);
        assert_eq!(input.sequence, Sequence::MAX);
        assert_eq!(input.witness.len(), 0); // No witness data in this test
        assert_eq!(coinbase.output.len(), 3);
        let output1 = &coinbase.output[0];
        let output2 = &coinbase.output[1];
        let output3 = &coinbase.output[2];

        assert_eq!(output1.value, Amount::from_str("49 BTC").unwrap());
        assert_eq!(output1.script_pubkey, address.script_pubkey());

        assert_eq!(output2.value, Amount::from_str("1 BTC").unwrap());
        assert_eq!(output2.script_pubkey, donation_address.script_pubkey());

        assert_eq!(output3.value, Amount::ZERO);
        assert_eq!(
            Some(output3.script_pubkey.to_hex_string()),
            template.default_witness_commitment
        );

        // Check the coinbase input script to make sure we got the expected string
        assert_eq!(coinbase.input[0].script_sig.len(), 37);
        let script_bytes = coinbase.input[0].script_sig.as_bytes();
        assert_eq!(script_bytes[0], 2);
        assert_eq!(script_bytes[1..3].as_hex().to_string(), "fa01"); // Height 506 in little-endian
        assert_eq!(script_bytes[3..5].as_hex().to_string(), "0100"); // Flags (empty in this case)
        assert_eq!(script_bytes[5..6].as_hex().to_string(), "04"); // Timestamp length
        assert_eq!(script_bytes[10..11].as_hex().to_string(), "04"); // Nanosecond timestamp length, don't check value as it changes with time
        assert_eq!(script_bytes[15..16].as_hex().to_string(), "0c"); // extranonce length, don't check value as it changes with time
        assert_eq!(script_bytes[16..28], EXTRANONCE_SEPARATOR); // Extranonce separator
        assert_eq!(script_bytes[28], 8u8); // Pool signature length
        assert_eq!(
            &script_bytes[29..37],
            POOL_SIGNATURE, // Check the pool signature
        );
    }
}
