// Copyright (C) 2024, 2025 P2Poolv2 Developers (see AUTHORS)
//
//  This file is part of P2Poolv2
//
// P2Poolv2 is free software: you can redistribute it and/or modify it under
// the terms of the GNU General Public License as published by the Free
// Software Foundation, either version 3 of the License, or (at your option)
// any later version.
//
// P2Poolv2 is distributed in the hope that it will be useful, but WITHOUT ANY
// WARRANTY; without even the implied warranty of MERCHANTABILITY or FITNESS
// FOR A PARTICULAR PURPOSE. See the GNU General Public License for more details.
//
// You should have received a copy of the GNU General Public License along with
// P2Poolv2. If not, see <https://www.gnu.org/licenses/>.

use crate::session::EXTRANONCE2_SIZE;
use crate::work::error::WorkError;
use bitcoin::absolute::LockTime;
use bitcoin::blockdata::script::{Builder, ScriptBuf};
use bitcoin::consensus::serialize;
use bitcoin::hashes::{sha256d, Hash};
use bitcoin::network::Network;
use bitcoin::script::PushBytesBuf;
use bitcoin::transaction::{Sequence, Transaction, TxIn, TxOut, Version};
use bitcoin::{Address, Amount};
use std::str::FromStr;

// Parse Address from a string provided by the miner
pub fn parse_address(address: &str, network: Network) -> Result<Address, WorkError> {
    let parsed_address = Address::from_str(address).map_err(|e| WorkError {
        message: format!("Invalid address: {}", e),
    })?;

    parsed_address
        .require_network(network)
        .map_err(|_| WorkError {
            message: format!("Address does not match network: {}", network),
        })
}

/// Get current timestamp, converted to hex bytes
fn get_current_timestamp_bytes() -> PushBytesBuf {
    let ts = (std::time::SystemTime::now()
        .duration_since(std::time::UNIX_EPOCH)
        .unwrap()
        .as_secs()) as u32;
    let mut ts_bytes = PushBytesBuf::new();
    let _ = ts_bytes.extend_from_slice(&ts.to_le_bytes());
    ts_bytes
}

/// Build a coinbase from the provided address, network and height.
/// This handles a single address for now - i.e. for solo mining.
/// TODO: Handle multiple addresses and payout proportions.
///
/// Example of a coinbase transaction:
/// coinbase generated by ckpool for regtest four txns
/// [2025-05-23 07:11:04.762] Coinb1: 01000000010000000000000000000000000000000000000000000000000000000000000000ffffffff2d02fa0100046803306804eba96d2d0c
/// [2025-05-23 07:11:04.762] Coinb2: 0a636b706f6f6c0a2f7032706f6f6c76322fffffffff034f2d822400000000
/// [2025-05-23 07:11:04.762] Header: 2000000065a7ea67c8083743a195e7ec5b424bdca660573756eab19968460fbf5e9a18370000000000000000000000000000000000000000000000000000000000000000683003
/// 68207fffff000000000000008000000000000000000000000000000000000000000000000000000000
///
/// Coinbase1:
/// 01000000010000000000000000000000000000000000000000000000000000000000000000ffffffff - standard header for single output coinbase
/// 2d - script length
/// 02fa01 - height
/// 00 - empty flags
/// 04 68033068 - timestamp seconds
/// 04 eba96d2d - enonce1 from tv_nsec ??
/// 0c - 12, the length of the two nonces put together
pub fn build_coinbase_transaction(
    address: Address,
    value: u64,
    height: i64,
    aux_flags: PushBytesBuf,
    extranonce1: u32,
    default_witness_commitment: Option<String>,
) -> Result<Transaction, WorkError> {
    let script_pubkey = address.script_pubkey();

    let mut extranonce_both = PushBytesBuf::from(extranonce1.to_le_bytes());
    extranonce_both
        .extend_from_slice(&[0u8; EXTRANONCE2_SIZE])
        .unwrap();

    let coinbase_script = Builder::new()
        .push_int(height)
        .push_slice(aux_flags)
        .push_slice(get_current_timestamp_bytes())
        .push_slice(extranonce_both) // push both in single push prefixes bytes length of 12, i.e. the 0c
        .into_script();

    let mut outputs = vec![TxOut {
        value: Amount::from_sat(value),
        script_pubkey,
    }];
    if let Some(default_witness_commitment) = default_witness_commitment {
        let commitment_bytes = hex::decode(&default_witness_commitment).map_err(|e| WorkError {
            message: format!("Invalid witness commitment hex: {}", e),
        })?;
        let commitment = ScriptBuf::from(commitment_bytes);
        outputs.push(TxOut {
            value: Amount::ZERO,
            script_pubkey: commitment,
        });
    }
    let coinbase_tx = Transaction {
        version: Version(2),
        lock_time: LockTime::ZERO,
        input: vec![TxIn {
            previous_output: bitcoin::OutPoint {
                txid: sha256d::Hash::all_zeros().into(),
                vout: u32::MAX,
            },
            script_sig: coinbase_script,
            sequence: Sequence::MAX,
            witness: Vec::<Vec<u8>>::new().into(),
        }],
        output: outputs,
    };
    Ok(coinbase_tx)
}

/// Splits the coinbase transaction into two parts: coinbase1 and coinbase2, separated by our
/// extranonce2 separator.
/// TODO: Replace with memchr or similar for performance optimization.
pub fn split_coinbase(coinbase: &Transaction) -> Result<(String, String), WorkError> {
    let deserialized_coinbase = serialize::<Transaction>(coinbase);
    let separator = [0u8; EXTRANONCE2_SIZE];
    let separator_pos = match deserialized_coinbase
        .as_slice()
        .windows(separator.len())
        .position(|window| window == separator)
    {
        Some(pos) => pos,
        None => {
            return Err(WorkError {
                message: "Invalid coinbase transaction".to_string(),
            })
        }
    };

    let coinbase1 = hex::encode(&deserialized_coinbase[..separator_pos]);
    let coinbase2 = hex::encode(&deserialized_coinbase[separator_pos + EXTRANONCE2_SIZE..]);
    Ok((coinbase1, coinbase2))
}

#[cfg(test)]
mod tests {
    use super::*;

    #[test]
    fn test_parse_address_valid_mainnet() {
        let addr = "1HpRF3JgafxaqjhMEjLNbevpRVvAp15t3A";
        let result = parse_address(addr, Network::Bitcoin);
        assert!(result.is_ok());
    }

    #[test]
    fn test_parse_address_valid_testnet() {
        let addr = "tb1q0afww6y0kgl4tyjjyv6xlttvfwdfqxvrfzz35f";
        let result = parse_address(addr, Network::Testnet);
        assert!(result.is_ok());
    }

    #[test]
    fn test_parse_address_invalid_format() {
        let addr = "not_a_valid_address";
        let result = parse_address(addr, Network::Bitcoin);
        assert!(result.is_err());
        assert!(result
            .err()
            .unwrap()
            .to_string()
            .contains("Invalid address"));
    }

    #[test]
    fn test_parse_address_wrong_network() {
        // This is a mainnet address, but we require testnet
        let addr = "1HpRF3JgafxaqjhMEjLNbevpRVvAp15t3A";
        let result = parse_address(addr, Network::Testnet);
        assert!(result.is_err());
        let msg = result.err().unwrap().to_string();
        println!("Error message: {}", msg);
        assert!(msg.contains("Address does not match network"));
        assert!(msg.contains("testnet"));
    }

    #[test]
    fn test_build_coinbase_transaction_without_default_witness() {
        let addr = parse_address(
            "1HpRF3JgafxaqjhMEjLNbevpRVvAp15t3A",
            bitcoin::Network::Bitcoin,
        )
        .unwrap();
        let value = 50_0000_0000u64; // 50 BTC in satoshis
        let height = 100;
        let coinbase = build_coinbase_transaction(
            addr.clone(),
            value,
            height,
            PushBytesBuf::from(&[0u8]),
            8888,
            None,
        )
        .unwrap();

        // Check version and lock_time
        assert_eq!(coinbase.version, Version(2));
        assert_eq!(coinbase.lock_time, LockTime::ZERO);

        // Check input
        assert_eq!(coinbase.input.len(), 1);
        let input = &coinbase.input[0];
        assert_eq!(
            input.previous_output.txid,
            sha256d::Hash::all_zeros().into()
        );
        assert_eq!(input.previous_output.vout, u32::MAX);
        assert_eq!(input.sequence, Sequence::MAX);

        let script_bytes = input.script_sig.as_bytes();
        // Check coinbase script contains height
        assert!(script_bytes.contains(&(height as u8)));
        // Check coinbase script contains extranonce1
        assert!(script_bytes.windows(4).any(|w| w == 8888_u32.to_le_bytes()));
        // Check coinbase script contains space for extranonce2
        assert!(script_bytes
            .windows(EXTRANONCE2_SIZE)
            .any(|w| w == [0u8; EXTRANONCE2_SIZE]));

        // Check output
        assert_eq!(coinbase.output.len(), 1);
        let output = &coinbase.output[0];
        assert_eq!(output.value, Amount::from_sat(value));
        assert_eq!(output.script_pubkey, addr.script_pubkey());
    }

    #[test]
    fn test_split_coinbase_without_default_commitment() {
        let addr = parse_address(
            "1HpRF3JgafxaqjhMEjLNbevpRVvAp15t3A",
            bitcoin::Network::Bitcoin,
        )
        .unwrap();
        let value = 50_0000_0000u64; // 50 BTC in satoshis
        let height = 100;
        let coinbase = build_coinbase_transaction(
            addr.clone(),
            value,
            height,
            PushBytesBuf::from(&[0u8]),
            8888,
            None,
        )
        .unwrap();

        let (coinbase1, coinbase2) = split_coinbase(&coinbase).unwrap();

        // Reconstruct the coinbase by concatenating coinbase1, extranonce2, and coinbase2
        let extranonce2 = [0u8; EXTRANONCE2_SIZE];
        let coinbase1_bytes = hex::decode(&coinbase1).unwrap();
        let coinbase2_bytes = hex::decode(&coinbase2).unwrap();

        let mut reconstructed = Vec::new();
        reconstructed.extend_from_slice(&coinbase1_bytes);
        reconstructed.extend_from_slice(&extranonce2);
        reconstructed.extend_from_slice(&coinbase2_bytes);

        let reconstructed_coinbase: Transaction =
            bitcoin::consensus::deserialize(&reconstructed).unwrap();
        assert_eq!(reconstructed_coinbase, coinbase);
    }

    #[test]
    fn test_get_current_timestamp_bytes() {
        let timestamp_bytes = get_current_timestamp_bytes();

        // Verify that the bytes length is 4 (u32 size)
        assert_eq!(timestamp_bytes.len(), 4);

        // Convert to ScriptBuf to check serialization
        let script = Builder::new().push_slice(timestamp_bytes).into_script();

        // When serialized to hex, should start with 04 (length prefix for 4 bytes)
        // followed by the actual timestamp bytes
        let script_hex = script.to_hex_string();
        assert!(script_hex.starts_with("04"));

        // Total length should be 10 chars:
        // - 2 chars for the length prefix (04)
        // - 8 chars for the timestamp bytes (4 bytes = 8 hex chars)
        assert_eq!(script_hex.len(), 10);

        // Try to parse the timestamp back from the bytes
        let timestamp_hex = &script_hex[2..]; // Skip the 04 prefix
        let timestamp_data = hex::decode(timestamp_hex).unwrap();
        let timestamp = u32::from_le_bytes(timestamp_data.try_into().unwrap());

        let now = std::time::SystemTime::now()
            .duration_since(std::time::UNIX_EPOCH)
            .unwrap()
            .as_secs() as u32;

        // Allow 10 second difference to account for test execution time
        assert!((now - timestamp) < 10);
    }
}
