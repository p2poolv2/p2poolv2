// Copyright (C) 2024 [Kulpreet Singh]
//
//  This file is part of P2Poolv2
//
// P2Poolv2 is free software: you can redistribute it and/or modify it under
// the terms of the GNU General Public License as published by the Free
// Software Foundation, either version 3 of the License, or (at your option)
// any later version.
//
// P2Poolv2 is distributed in the hope that it will be useful, but WITHOUT ANY
// WARRANTY; without even the implied warranty of MERCHANTABILITY or FITNESS
// FOR A PARTICULAR PURPOSE. See the GNU General Public License for more details.
//
// You should have received a copy of the GNU General Public License along with
// P2Poolv2. If not, see <https://www.gnu.org/licenses/>.

use crate::node::behaviour::request_response::RequestResponseEvent;
use crate::node::messages::Message;
use crate::node::p2p_message_handlers::handle_request;
use crate::node::SwarmSend;
#[mockall_double::double]
use crate::shares::chain::actor::ChainHandle;
use crate::utils::time_provider::SystemTimeProvider;
use libp2p::request_response::ResponseChannel;
use std::error::Error;
use tokio::sync::mpsc;
use tracing::{debug, error, info};

/// Handle request-response events, these are events that are generated by the request-response protocol
/// The caller spawns a new task to handle the event to allow concurrent handling of events
pub async fn handle_request_response_event(
    event: RequestResponseEvent<Message, Message>,
    chain_handle: ChainHandle,
    swarm_tx: mpsc::Sender<SwarmSend<ResponseChannel<Message>>>,
) -> Result<(), Box<dyn Error>> {
    info!("Request-response event: {:?}", event);
    match event {
        RequestResponseEvent::Message {
            peer,
            message:
                libp2p::request_response::Message::Request {
                    request_id: _,
                    request,
                    channel: response_channel,
                },
        } => {
            debug!("Received request from peer: {}", peer);
            let time_provider = SystemTimeProvider {};
            if let Err(e) = handle_request::<ResponseChannel<Message>>(
                peer,
                request,
                chain_handle,
                response_channel,
                swarm_tx,
                &time_provider,
            )
            .await
            {
                error!("Failed to handle request: {}", e);
                return Err("Error handling request".into());
            }
        }
        RequestResponseEvent::Message {
            peer,
            message:
                libp2p::request_response::Message::Response {
                    request_id,
                    response: _,
                },
        } => {
            debug!(
                "Received response for request: {} from peer: {}",
                request_id, peer
            );
        }
        RequestResponseEvent::OutboundFailure {
            peer,
            request_id,
            error,
        } => {
            debug!(
                "Outbound failure from peer: {peer}, request_id: {request_id}, error: {error:?}"
            );
        }
        RequestResponseEvent::InboundFailure {
            peer,
            request_id,
            error,
        } => {
            debug!("Inbound failure from peer: {peer}, request_id: {request_id}, error: {error:?}");
        }
        RequestResponseEvent::ResponseSent { peer, request_id } => {
            debug!("Response sent to peer: {peer}, request_id: {request_id}");
        }
    }
    Ok(())
}
